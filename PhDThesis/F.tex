\chapter{Theme 3: Verified Model to Verified Code}
Model checking is performed on abstract models of the system, which is at an early stage in the development process. The verified system model during model checking is then translated into a Stateflow model, which is a step towards simulation-based testing and subsequently to code generation. Closed-loop simulation/testing are performed on more refined deterministic models, and on the actual system, complement model checking in terms of resolving ambiguities within abstract counterexamples. We aim to answer the following questions here:

\begin{itemize}
	\vspace{-5pt}
	\item How are abstract models translated to deterministic models for simulation-based testing?
	\vspace{-5pt}
	\item What system level issues are best tested at the platform level?
\end{itemize}

In this chapter, we first describe an approach to automatically translate formal models that are verified in UPPAAL to Stateflow charts for simulation-based testing, and then code generated to run on an embedded platform. Following this, we demonstrate two examples that cannot be explicitly modeled using abstract semantics and must be tested.

\section{UPPAAL to Stateflow Automated Model Translation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!b]
\centering
		\subfigure 
		{			
		\includegraphics[width=0.45\textwidth]{figs/method_new1.png}		
		\label{fig:method}
		}
		\hspace{.2in} 
		\subfigure 
		{	
			\includegraphics[width=0.45\textwidth]{figs/chart_GlobalClocks_rev1.png}
			\label{fig:chart}
		}
\caption{(a)~Model Driven Design framework: From UPPAAL to Stateflow to generated code -- covering model verification, simulation-based testing and platform testing.~(b) Structure of Stateflow charts of the pacemaker's five basic timing cycles (from Fig. \ref{fig:PMdesign}) derived by the UPP2SF model translator. Parent states $P_1,...,P_n$ are derived from automata, while the \textit{clock} states $Gc\_{x_1},..., Gc\_{x_m}$ model all global clocks $x_1,...,x_m$ from the UPPAAL model. The state $Eng$ is used to control execution of the chart.}
\label{fig:upp2sftool}
\end{figure*} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A model translation tool, UPP2SF (\cite{TECS}) was developed to translate UPPAAL models to Stateflow (see \figref{method}). Consider an UPPAAL model with automata $P_1,...,P_n$.  After UPP2SF translation, a two-level Stateflow chart is generated as in \figref{chart}. The chart consists of parallel states $P_1,...,P_n$ (referred to as the \textit{parent} states) derived from the automata, parallel states $Gc\_{x_1},..., Gc\_{x_m}$ (referred to as \textit{clock states}) that model all global clocks $x_1,...,x_m$ from the UPPAAL model, and the state $Eng$ that is used as the chart's control execution engine.
Moreover, the chart has predefined global data variables (and constants) with appropriate ranges and initial values derived from the UPPAAL model. 
Since all automata in UPPAAL are active simultaneously, the obtained Stateflow chart is a collection of parallel states with unique execution orders. Also, in every UPPAAL automaton exactly one location is active at a time. Thus, each of the parent states is a collection of exclusive states, extracted from locations in the corresponding UPPAAL automaton. 

In \cite{TECS}, we showed that for a large class of UPPAAL models, the generated Stateflow models generated by UPP2SF preserve behaviors of the initial UPPAAL models. The translation tool can be used to estimate the worst case execution time (WCET) during modeling and model checking stage in UPPAAL, and facilitates development of modular code from timed-automata based models. 

%%\begin{figure} [!t]
%%\center
%%\includegraphics[width=0.48\textwidth]{figs/chart_GlobalClocks_rev1.png} 
%%\caption{}
%%\label{fig:chart}
%%\end{figure}

\figref{PM_sf} demonstrates the Stateflow chart generated from the UPPAAL model of the DDD pacemaker model in \figref{PMdesign} using the UPP2SF tool.
\begin{figure*} [!t]
\center
\includegraphics[width=0.77\textwidth]{figs/PM_SF_buffer_newC1.png} 
\caption{Pacemaker Stateflow chart converted from the UPPAAL model in~\figref{PMdesign} using UPP2SF; the heart and buffer models are highlighted.} 
\label{fig:PM_sf}
\end{figure*}
We generated C code from the pacemaker Stateflow chart using the Simulink Coder. The code structure is shown in \figref{pm_code}.
The code was generated for the general embedded real-time target and as a result we obtained the main procedure, \texttt{rt\_OneStep}, which processes the three input events, $VinB$, $AinB$ and $clk$. To ensure that the model semantics are preserved (modulo the execution time), $clk$ input events should be created every 1ms, followed by the procedure's activation. This makes it suitable for implementation on top of a real-time operating system (RTOS).

\begin{figure*} [!t]
\center
\includegraphics[width=\textwidth]{figs/CodeListingFinal.png}
\caption{Structure of the pacemaker code obtained from the Stateflow chart shown in \figref{PM_sf}.}
\label{fig:pm_code}
\end{figure*}


The pacemaker code generated by the Simulink Real-Time Workshop's Embedded Coder was executed on nanoRK (\cite{nanork}), a fixed-priority preemptive RTOS that runs on a variety of resource constrained platforms. We tested the implementation on the TI MSP-EXP430F5438 Experimenter Board interfaced with a signal generator that provides inputs for the pacemaker code (\figref{setup}). More details regarding UPP2SF translation and platform testing can be found in \cite{TECS}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!t]
\centering
		\subfigure 
		{			
		\includegraphics[width=0.46\textwidth]{figs/HM_PM_newMon.png}
		\label{fig:hm_pm}
		}
		\subfigure 
		{	
			\includegraphics[width=0.48\textwidth]{figs/HW_setup1.png}
			\label{fig:PM_timer}
		} 
\caption{(a)~Structure of the pacemaker model in UPPAAL and Stateflow, including the interaction between the pacemaker and heart, and the monitors used for verification. (b) Hardware setup with MSP430F5438 experimenters board.}
\label{fig:setup}
\end{figure*} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Summary:}
In this chapter, we first introduced a model translation method from UPPAAL timed automata models to Stateflow charts. Combined with Simulink coder, the tool chain provides rigorous evidence of traceability from physiological requirements to the C code implementation. Oversensing, crosstalk and lead displacement are three examples in which the cause of the problem is not modeled in the abstract interface in the timed-automata model. In such cases, closed-loop testing with the more refined heart models and EGM interface can be used to provide safety evidence.


%\subsection{Acknowledgements}
%\begin{acknowledgements}
%\addcontentsline{toc}{chapter}{Acknowledgements} 
%The authors would like to thank Houssam Abbas, Rajeev Alur, George M. Chen, Allison Connolly, Sanjay Dixit, Insup Lee, Pieter Mosterman, Miroslav Pajic, Oleg Sokolsky and Larisa G. Tereshchenko for fruitful discussions during the preparation of this manuscript. This research was supported in part by NSF CNS-0720518, NSF CNS-1035715, NSF MRI-0923518, NSF CPS Frontier 1446664 and NSF CAREER-1253842 grants. This work was also supported in part by STARnet - a Semiconductor Research Corporation program sponsored by MARCO and DARPA.
%\end{acknowledgements}
%%\chapter{Certification}
%%\begin{itemize}
%%          	\item What is the current practice for medical device certification? What are the limitations?
%%          	\item Can model-based closed-loop verification provide more safety guarantee to complement current practice? By how much?
%%          \end{itemize}
%%          
%%\section{Current Practice}
%%%In United States, medical devices have to be approved by FDA to be released into the market. 
%%According to their potential risks the devices are categorized into 3 classes, Class I, Class II and Class III, corresponding to low-risk, medium-risk and high-risk devices \cite{class}. Life-sustaining devices like implantable pacemakers are classified as Class III and in general are subject to the most strict regulations.
%%
%%There are two processes that a medical device can enter the market in U.S.: the Premarket Notification, also known as 510(k) \cite{510k}, and the Pre-Market Approval (PMA) \cite{PMA}. In a 510(k) submission the device manufacturers are only required to provide evidence that the device is \emph{substantial equivalent} to a \emph{predicate device}, which has been approved for the market. Therefore, the 510(k) submission does not directly require clinical evidence for the safety and effectiveness of the device, thus is suitable for mostly low-risk devices like Class I and Class II devices.  The Pre-Market Approval (PMA) submission is a more stringent regulatory process in which direct clinical evidence is required to prove the safety and effectiveness of the device. However, not all Class III devices are subject to PMA submission. If a Class III device clears the 510(k) process and FDA has not requested PMA for that device, the device is still cleared for market release. A study shows that for Class III devices which PMA has been requested, the levels of evidence varies. Only 40\% of the PMA submissions are supported by controlled clinical trials, which provide the most rigorous clinical evidence \cite{cert_prob}. The lack of quality evidence is usually due to the high cost of the controlled clinical trials.
%%\section{Evidence from Model-based Design}
%%%\cite{pancreas}
%%Model-based verification provides a low-cost solution to provide reasonable evidence for the safety and effectiveness of the devices. The open questions are:
%%
%%\begin{itemize}
%%	\item How valid are the models?
%%	\item How much confidence can they provide?
%%\end{itemize}
